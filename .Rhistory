geom_vline(xintercept = 3500, linetype = 'dashed', size = 0.25) +
annotate(geom="text",x=1000,
y=7000,label="7,400 MWh/a in 2021 from plot above") +
annotate(geom="text",x=4000,
y=2000,label="min 3.5 MW") +
annotate(geom="text",x=4500,
y=11500,label= "R² = ~ 79 %") +
scale_colour_manual(name = "Year", values=c("#03a1fc", "#fc5a03", "#94fc03"))
#print plot
pe_over_ratedcapacity_2019 +  theme(legend.position = c(0.25,0.9))
#linear models with rated capacity over commissioning date
lm_rated_capacity_over_time_2019 <- lm(
amprion_2019$leistung ~ amprion_2019$inbetriebnahme)
lm_rated_capacity_over_time_2019 <- lm(
amprion_2019$leistung ~ amprion_2019$inbetriebnahme)
summary(lm_rated_capacity_over_time_2019)
plot(lm_rated_capacity_over_time_2019)
prated_capacity_over_commission <- ggplot() +
geom_point(data = amprion_2019,
aes(x=inbetriebnahme, y=leistung),
size = 0.4, colour = "#94fc03") +
geom_smooth(data = amprion_2019,
aes(x=inbetriebnahme, y=leistung, colour = "2019"),
method=lm, se=TRUE, fullrange = TRUE, size = 0.5)  +
theme_light() +
scale_x_date(limits = as.Date(c("1990-01-01","2030-12-31"))) +
ylim(-1000, 6000) +
xlab("Commissioning Date") +
ylab("Rated capacity [kW]") +
theme( axis.text=element_text(size=11),
axis.title=element_text(size=12),
plot.title = element_text(size=14),
legend.position = c(0.85, 0.9),
legend.direction = "horizontal") +
geom_hline(yintercept = 3500, linetype = 'dashed', size = 0.25) +
annotate(geom="text",x=as.Date("1997-01-01"),
y=3300,label="mean of ~ 3,500 kW in 2021", size = 2.5) +
geom_hline(yintercept = 4500, linetype = 'dashed', size = 0.25) +
annotate(geom="text",x=as.Date("1997-01-01"),
y=4700,label="Predicted mean of ~ 4,500 kW in 2030", size = 2.5) +
annotate(geom="text",x=as.Date("2025-01-01"),
y=0,label= "R² = ~ 70 %") +
scale_colour_manual(name = "Year", values="#94fc03")
#print plot
prated_capacity_over_commission +  theme(legend.position = c(0.25,0.9))
#linear models with full load hours  over the commissioning date 2015 - 2019
#2015
lm_flh_2015 <- lm(
amprion_2015$flh ~ amprion_2015$inbetriebnahme)
summary(lm_flh_2015)
#2016
lm_flh_2016 <- lm(
amprion_2016$flh ~ amprion_2016$inbetriebnahme)
#2017
lm_flh_2017 <- lm(
amprion_2017$flh ~ amprion_2017$inbetriebnahme)
#2018
lm_flh_2018 <- lm(
amprion_2018$flh ~ amprion_2018$inbetriebnahme)
#2019
lm_flh_2019 <- lm(
amprion_2019$flh ~ amprion_2019$inbetriebnahme)
#plot full load hours over commissioning date with trend
pflh <- ggplot() +
geom_point(data = amprion_2015, aes(x=inbetriebnahme, y=flh),
size = 0.4, colour = "#fd00e2") +
geom_point(data = amprion_2016, aes(x=inbetriebnahme, y=flh),
size = 0.4, colour = "#fde600") +
geom_point(data = amprion_2017, aes(x=inbetriebnahme, y=flh),
size = 0.4, colour = "#03a1fc") +
geom_point(data = amprion_2018, aes(x=inbetriebnahme, y=flh),
size = 0.4, colour = "#fc5a03") +
geom_point(data = amprion_2019, aes(x=inbetriebnahme, y=flh),
size = 0.4, colour = "#94fc03") +
geom_smooth(data = amprion_2015,
aes(x=inbetriebnahme, y=flh, colour = "2015"),
method=lm, se=TRUE, fullrange = TRUE, size = 0.5)  +
geom_smooth(data = amprion_2016,
aes(x=inbetriebnahme, y=flh, colour = "2016"),
method=lm, se=TRUE, fullrange = TRUE, size = 0.5)  +
geom_smooth(data = amprion_2017,
aes(x=inbetriebnahme, y=flh, colour = "2017"),
method=lm, se=TRUE, fullrange = TRUE, size = 0.5)  +
geom_smooth(data = amprion_2018,
aes(x=inbetriebnahme, y=flh, colour = "2018"),
method=lm, se=TRUE, fullrange = TRUE, size = 0.5)  +
geom_smooth(data = amprion_2019,
aes(x=inbetriebnahme, y=flh, colour = "2019"),
method=lm, se=TRUE, fullrange = TRUE, size = 0.5)  +
theme_light() +
scale_x_date(limits = as.Date(c("1990-01-01","2030-12-31"))) +
ylim(0, 4000) +
xlab("Commissioning Date") +
ylab("Full load hours [h/a]") +
theme( axis.text=element_text(size=11),
axis.title=element_text(size=12),
plot.title = element_text(size=14),
legend.position = c(0.85, 0.9),
legend.direction = "horizontal") +
geom_hline(yintercept = 2300, linetype = 'dashed', size = 0.25) +
annotate(geom="text",x=as.Date("1997-01-01"),
y=2200,label="mean of ~ 2,300 h/a in 2021 with linear trends",
size = 2.5) +
geom_hline(yintercept = 2800, linetype = 'dashed', size = 0.25) +
annotate(geom="text",x=as.Date("2000-01-01"),
y=2900,label="mean of ~ 2,800 h/a in 2030 with linear trends",
size = 2.5) +
geom_hline(yintercept = 15000, linetype = 'dashed', size = 0.25) +
annotate(geom="text",x=as.Date("2003-01-01"),
y=14200, label="> 15,000 MWh/a in 2030 with polynomial models",
size = 2.5) +
annotate(geom="text",x=as.Date("2026-01-01"),
y=800,label= "All R²  ~ 46 - 51 %", size = 2.5) +
annotate(geom="text",x=as.Date("2026-01-01"),
y=400,label="p-values all << 0.001", size = 2.5) +
scale_colour_manual(name = "Year",
values=c("#fd00e2", "#fde600",
"#03a1fc", "#fc5a03", "#94fc03"))
#print plot
pflh +  theme(legend.position = c(0.35,0.93))
#save plot as image
ggsave("results_of_analysis/electricity_yield_2017-2019.png",
plot = last_plot(),
dpi = 900,
width = 7,
height = 4)
ggsave("results_of_analysis/electricity_yield_2017-2019.png",
plot = last_plot(),
dpi = 900,
width = 7,
height = 4)
#Plot the values with linear and polynomial trends for 2017 - 2019
pelectricity_yield_2019_poly <- ggplot() +
geom_point(data = amprion_2017, aes(x=inbetriebnahme, y=menge_mwh),
size = 0.4, colour = "#03a1fc") +
geom_point(data = amprion_2018, aes(x=inbetriebnahme, y=menge_mwh),
size = 0.4, colour = "#fc5a03") +
geom_point(data = amprion_2019, aes(x=inbetriebnahme, y=menge_mwh),
size = 0.4, colour = "#94fc03") +
geom_smooth(data = amprion_2017,
aes(x=inbetriebnahme, y=menge_mwh, colour = "2017"),
method=lm, se=TRUE, fullrange = TRUE, size = 0.5)  +
geom_smooth(data = amprion_2018,
aes(x=inbetriebnahme, y=menge_mwh, colour = "2018"),
method=lm, se=TRUE, fullrange = TRUE, size = 0.5)  +
geom_smooth(data = amprion_2019,
aes(x=inbetriebnahme, y=menge_mwh, colour = "2019"),
method=lm, se=TRUE, fullrange = TRUE, size = 0.5)  +
geom_smooth(data = amprion_2017,
aes(x=inbetriebnahme, y=menge_mwh, colour = "2017"),
method= "lm", formula = y ~ poly(x, 3),
fullrange = TRUE, size = 0.5)  +
geom_smooth(data = amprion_2018,
aes(x=inbetriebnahme, y=menge_mwh, colour = "2018"),
method= "lm", formula = y ~ poly(x, 3),
fullrange = TRUE, size = 0.5)  +
geom_smooth(data = amprion_2019,
aes(x=inbetriebnahme, y=menge_mwh, colour = "2019"),
method= "lm", formula = y ~ poly(x, 3),
fullrange = TRUE, size = 0.5)  +
theme_light() +
scale_x_date(limits = as.Date(c("1990-01-01","2030-12-31"))) +
ylim(-1000, 20000) +
xlab("Commissioning Date") +
ylab("Electricity yield per WT and year [MWh]") +
theme( axis.text=element_text(size=11),
axis.title=element_text(size=12),
plot.title = element_text(size=14),
legend.position = c(0.85, 0.9),
legend.direction = "horizontal") +
geom_hline(yintercept = 7400, linetype = 'dashed', size = 0.25) +
annotate(geom="text",x=as.Date("1997-01-01"),
y=6500,label="mean of ~ 7,400 MWh/a in 2021 with linear trends",
size = 2.5) +
geom_hline(yintercept = 10000, linetype = 'dashed', size = 0.25) +
annotate(geom="text",x=as.Date("2000-01-01"),
y=11000,label="mean of ~ 10,000 MWh/a in 2030 with linear trends",
size = 2.5) +
geom_hline(yintercept = 15000, linetype = 'dashed', size = 0.25) +
annotate(geom="text",x=as.Date("2003-01-01"),
y=14200, label="> 15,000 MWh/a in 2030 with polynomial models",
size = 2.5) +
annotate(geom="text",x=as.Date("2026-01-01"),
y=2000,label= "All adj. R² (3rd poly) ~ 72 %", size = 2.5) +
annotate(geom="text",x=as.Date("2026-01-01"),
y=3500,label= "All R² (linear) ~ 68 - 70 %", size = 2.5) +
annotate(geom="text",x=as.Date("2026-01-01"),
y=400,label="p-values all << 0.001", size = 2.5) +
scale_colour_manual(name = "Year", values=c("#03a1fc", "#fc5a03", "#94fc03"))
#print plot
pelectricity_yield_2019_poly +  theme(legend.position = c(0.25,0.9))
#save plot as image
ggsave("results_of_analysis/electricity_yield_2017-2019.png",
plot = last_plot(),
dpi = 900,
width = 7,
height = 4)
Sys.setenv(LANG = "en")
pacman::p_load(rio, data.table, tidyverse, tidyr, purrr, magrittr, compare,
ggplot2, leaflet, sp, raster, rgdal, htmltools, htmlwidgets,
tmaptools, maptools, raster, sf, tmap, spatstat, rgeos)
setwd("C:/Users/Dell/Desktop/MasterThesis/thesis_elias_cuadra_219202265/data/Area_consumption_of_wind_turbines")
MaStR_amprion <- read.csv("MaStR_amprion2019.csv")
attach(MaStR_amprion)
View(MaStR_amprion)
MaStR_amprion$l_wgs84 <- gsub(",",".", l_wgs84)
MaStR_amprion$b_wgs84 <- gsub(",",".", b_wgs84)
MaStR_amprion$b_wgs84 <- as.numeric(MaStR_amprion$b_wgs84)
MaStR_amprion$l_wgs84 <- as.numeric(MaStR_amprion$l_wgs84)
border_sf  <- st_read("Borders_RLP_shape/Landesgrenze_RLP.shp")
border_sp <- readOGR("Borders_RLP_shape/Landesgrenze_RLP.shp")
#create coordinate columns and check CRS
class(MaStR_amprion)
coordinates(MaStR_amprion) <- ~ l_wgs84 + b_wgs84
crs(MaStR_amprion)
#create crs
WGS84 <- CRS("+proj=longlat +datum=WGS84 +no_defs")
crs(MaStR_amprion) <- WGS84
crs(MaStR_amprion)
#clip those inside RLP
wts_rlp <- MaStR_amprion[border_sp,]
wts_rlp_df <- as.data.frame(wts_rlp)
#convert point layer to in sf format
wts_rlp_sf <- st_as_sf(wts_rlp)
crs(wts_sf)
class(wts_sf)
#transform point layer of wts to flat
wts_rlp_flat <- st_transform(wts_rlp_sf, crs = 6345)
plot(wts_flat)
#transform border polygon of RLP to flat
border_flat <- st_transform(border_sf, crs = 6345)
plot(wts_flat)
pacman::p_load(rio, data.table, tidyverse, tidyr, purrr, magrittr, compare,
ggplot2, leaflet, sp, raster, rgdal, htmltools, htmlwidgets,
tmaptools, maptools, raster, sf, tmap, spatstat, rgeos)
#convert point layer to in sf format
wts_rlp_sf <- st_as_sf(wts_rlp)
crs(wts_sf)
class(wts_sf)
#transform point layer of wts to flat
wts_rlp_flat <- st_transform(wts_rlp_sf, crs = 6345)
plot(wts_flat)
plot(wts_rlp_flat)
#create ppp formate of WT's
wts_rlp_ppp  <- as.ppp(wts_rlp_flat)
#create owin format
border_owin <- as.owin(border_flat)
#create window of points with borders of rlp and plot
Window(wts_rlp_ppp) <- border_owin
plot(wts_rlp_ppp, cols=rgb(0,0,0,.2), pch=20)
#calculate average nearest neighbor
mean(nndist(wts_rlp_ppp, k=1))
#calculate nearest neighbor
nearest <- nndist(wts_rlp_ppp, k=1)
wts_rlp_distances <- data.frame(wts_rlp_df, nearest)
wts_rlp_distances$nearest <- round(wts_rlp_distances$nearest)
#plot with leaflet
leaflet(data = wts_rlp_distances) %>%
addTiles() %>%
addPolygons(data = border_sp,
color = "#5DADE2",
weight = 2,
opacity = 0.6,
fillColor = "#5DADE200",
highlight = highlightOptions(weight = 7,
color = "#5DADE2",
fillColor = "#5DADE2",
fillOpacity = 0.3,
bringToFront = TRUE),
label = "Rheinland-Pfalz",
group = "Rheinland-Pfalz") %>%
addMarkers(lng = wts_rlp$l_wgs84,
lat = wts_rlp$b_wgs84,
clusterOptions = markerClusterOptions(disableClusteringAtZoom = 10),
popup = ~paste("<h3> Daten der Windkraftanlage</h3>",
"<b>Distance to next WT:</b>", nearest, "<br>"))
#import data
MaStR_amprion <- read.csv("MaStR_amprion2019.csv")
attach(MaStR_amprion)
#change lat and long to numeric
MaStR_amprion$l_wgs84 <- gsub(",",".", l_wgs84)
MaStR_amprion$b_wgs84 <- gsub(",",".", b_wgs84)
MaStR_amprion$b_wgs84 <- as.numeric(MaStR_amprion$b_wgs84)
MaStR_amprion$l_wgs84 <- as.numeric(MaStR_amprion$l_wgs84)
#load boundaries of RLP
border_sf  <- st_read("Borders_RLP_shape/Landesgrenze_RLP.shp")
border_sp <- readOGR("Borders_RLP_shape/Landesgrenze_RLP.shp")
#create coordinate columns and check CRS
class(MaStR_amprion)
coordinates(MaStR_amprion) <- ~ l_wgs84 + b_wgs84
crs(MaStR_amprion)
#create crs
WGS84 <- CRS("+proj=longlat +datum=WGS84 +no_defs")
crs(MaStR_amprion) <- WGS84
crs(MaStR_amprion)
#clip those inside RLP
wts_rlp <- MaStR_amprion[border_sp,]
wts_rlp_df <- as.data.frame(wts_rlp)
#convert point layer to in sf format
wts_rlp_sf <- st_as_sf(wts_rlp)
crs(wts_sf)
class(wts_sf)
#transform point layer of wts to flat
wts_rlp_flat <- st_transform(wts_rlp_sf, crs = 6345)
plot(wts_rlp_flat)
#transform border polygon of RLP to flat
border_flat <- st_transform(border_sf, crs = 6345)
##############################
#PPA - Point Pattern Analysis#
##############################
#create ppp formate of WT's
wts_rlp_ppp  <- as.ppp(wts_rlp_flat)
plot(wts_rlp_ppp)
#create owin format
border_owin <- as.owin(border_flat)
#create window of points with borders of rlp and plot
Window(wts_rlp_ppp) <- border_owin
plot(wts_rlp_ppp, cols=rgb(0,0,0,.2), pch=20)
#calculate average nearest neighbor
mean(nndist(wts_rlp_ppp, k=1))
#~549m -----> seems reasonable
#calculate nearest neighbor
nearest <- nndist(wts_rlp_ppp, k=1)
wts_rlp_distances <- data.frame(wts_rlp_df, nearest)
wts_rlp_distances$nearest <- round(wts_rlp_distances$nearest)
#plot with leaflet
leaflet(data = wts_rlp_distances) %>%
addTiles() %>%
addPolygons(data = border_sp,
color = "#5DADE2",
weight = 2,
opacity = 0.6,
fillColor = "#5DADE200",
highlight = highlightOptions(weight = 7,
color = "#5DADE2",
fillColor = "#5DADE2",
fillOpacity = 0.3,
bringToFront = TRUE),
label = "Rheinland-Pfalz",
group = "Rheinland-Pfalz") %>%
addMarkers(lng = wts_rlp$l_wgs84,
lat = wts_rlp$b_wgs84,
clusterOptions = markerClusterOptions(disableClusteringAtZoom = 10),
popup = ~paste("<h3> Daten der Windkraftanlage</h3>",
"<b>Distance to next WT:</b>", nearest, "<br>"))
#clean environment
rm(border_sp, border_flat, border_owin, border_sf, wts_rlp_ppp, wts_rlp_flat,
wts_rlp_sf, nearest, MaStR_amprion, WGS84, wts_rlp_df, wts_rlp)
View(wts_rlp_distances)
#create colum with mwh and area
wts_rlp_distances <- wts_rlp_distances %>%
mutate(menge_mwh = round(menge_kwh/1000)) %>%
mutate(area_m2 = round(nearest^2)) %>%
mutate(area_km2 = area_m2/1000000) %>%
mutate(kwh_m2 = menge_kwh/area_m2) %>%
mutate(d = round(nearest/rotor_m))
View(wts_rlp_distances)
mutate(kwh_m2 = round((menge_kwh/area_m2),4) %>%
?round
#create colum with mwh and area
wts_rlp_distances <- wts_rlp_distances %>%
mutate(menge_mwh = round(menge_kwh/1000)) %>%
mutate(area_m2 = round(nearest^2)) %>%
mutate(area_km2 = area_m2/1000000) %>%
mutate(kwh_m2 = round(menge_kwh/area_m2),4) %>%
mutate(d = round(nearest/rotor_m))
#import data
MaStR_amprion <- read.csv("MaStR_amprion2019.csv")
attach(MaStR_amprion)
#change lat and long to numeric
MaStR_amprion$l_wgs84 <- gsub(",",".", l_wgs84)
MaStR_amprion$b_wgs84 <- gsub(",",".", b_wgs84)
MaStR_amprion$b_wgs84 <- as.numeric(MaStR_amprion$b_wgs84)
MaStR_amprion$l_wgs84 <- as.numeric(MaStR_amprion$l_wgs84)
#load boundaries of RLP
border_sf  <- st_read("Borders_RLP_shape/Landesgrenze_RLP.shp")
border_sp <- readOGR("Borders_RLP_shape/Landesgrenze_RLP.shp")
#create coordinate columns and check CRS
class(MaStR_amprion)
coordinates(MaStR_amprion) <- ~ l_wgs84 + b_wgs84
crs(MaStR_amprion)
#create crs
WGS84 <- CRS("+proj=longlat +datum=WGS84 +no_defs")
crs(MaStR_amprion) <- WGS84
crs(MaStR_amprion)
#clip those inside RLP
wts_rlp <- MaStR_amprion[border_sp,]
wts_rlp_df <- as.data.frame(wts_rlp)
#convert point layer to in sf format
wts_rlp_sf <- st_as_sf(wts_rlp)
crs(wts_sf)
class(wts_sf)
#transform point layer of wts to flat
wts_rlp_flat <- st_transform(wts_rlp_sf, crs = 6345)
plot(wts_rlp_flat)
#transform border polygon of RLP to flat
border_flat <- st_transform(border_sf, crs = 6345)
##############################
#PPA - Point Pattern Analysis#
##############################
#create ppp formate of WT's
wts_rlp_ppp  <- as.ppp(wts_rlp_flat)
plot(wts_rlp_ppp)
#create owin format
border_owin <- as.owin(border_flat)
#create window of points with borders of rlp and plot
Window(wts_rlp_ppp) <- border_owin
plot(wts_rlp_ppp, cols=rgb(0,0,0,.2), pch=20)
#calculate average nearest neighbor
mean(nndist(wts_rlp_ppp, k=1))
#~549m -----> seems reasonable
#calculate nearest neighbor
nearest <- nndist(wts_rlp_ppp, k=1)
wts_rlp_distances <- data.frame(wts_rlp_df, nearest)
wts_rlp_distances$nearest <- round(wts_rlp_distances$nearest)
#create colum with mwh and area
wts_rlp_distances <- wts_rlp_distances %>%
mutate(menge_mwh = round(menge_kwh/1000)) %>%
mutate(area_m2 = round(nearest^2)) %>%
mutate(area_km2 = area_m2/1000000) %>%
mutate(kwh_m2 = round(menge_kwh/area_m2),4) %>%
mutate(d = round(nearest/rotor_m))
wts_rlp_distances <- data.frame(wts_rlp_df, nearest)
wts_rlp_distances$nearest <- round(wts_rlp_distances$nearest)
wts_rlp_distances <- wts_rlp_distances %>%
mutate(menge_mwh = round(menge_kwh/1000)) %>%
mutate(area_m2 = round(nearest^2)) %>%
mutate(area_km2 = area_m2/1000000) %>%
mutate(kwh_m2 = round((menge_kwh/area_m2),4)) %>%
mutate(d = round(nearest/rotor_m))
wts_rlp_distances <- data.frame(wts_rlp_df, nearest)
wts_rlp_distances$nearest <- round(wts_rlp_distances$nearest)
#create colum with mwh and area
wts_rlp_distances <- wts_rlp_distances %>%
mutate(menge_mwh = round(menge_kwh/1000)) %>%
mutate(area_m2 = round(nearest^2)) %>%
mutate(area_km2 = area_m2/1000000) %>%
mutate(kwh_m2 = round((menge_kwh/area_m2), digits = 4)) %>%
mutate(d = round(nearest/rotor_m))
wts_rlp_distances <- data.frame(wts_rlp_df, nearest)
wts_rlp_distances$nearest <- round(wts_rlp_distances$nearest)
#create colum with mwh and area
wts_rlp_distances <- wts_rlp_distances %>%
mutate(menge_mwh = round(menge_kwh/1000)) %>%
mutate(area_m2 = round(nearest^2)) %>%
mutate(area_km2 = round((area_m2/1000000), digits = 3) %>%
mutate(kwh_m2 = round((menge_kwh/area_m2), digits = 3) %>%
mutate(d = round(nearest/rotor_m))
wts_rlp_distances <- wts_rlp_distances %>%
mutate(menge_mwh = round(menge_kwh/1000)) %>%
mutate(area_m2 = round(nearest^2)) %>%
mutate(area_km2 = round((area_m2/1000000), digits = 3) %>%
mutate(kwh_m2 = round(menge_kwh/area_m2, digits = 3) %>%
mutate(d = round(nearest/rotor_m))
wts_rlp_distances <- data.frame(wts_rlp_df, nearest)
wts_rlp_distances$nearest <- round(wts_rlp_distances$nearest)
wts_rlp_distances <- wts_rlp_distances %>%
mutate(menge_mwh = round(menge_kwh/1000)) %>%
mutate(area_m2 = round(nearest^2)) %>%
mutate(area_km2 = round(area_m2/1000000, digits = 3)) %>%
mutate(kwh_m2 = round(menge_kwh/area_m2, digits = 3)) %>%
mutate(d = round(nearest/rotor_m))
View(wts_rlp_distances)
#clean environment
rm(border_sp, border_flat, border_owin, border_sf, wts_rlp_ppp, wts_rlp_flat,
wts_rlp_sf, nearest, MaStR_amprion, WGS84, wts_rlp_df, wts_rlp)
#write csv file
write.csv(wts_rlp_distances, "wts_rlp_distances")
#write csv file
write.csv(wts_rlp_distances, "wts_rlp_distances.csv")
setwd("C:/Users/Dell/Desktop/MasterThesis/thesis_elias_cuadra_219202265/data/MaStR_amprion_analysis")
Sys.setenv(LANG = "en")
pacman::p_load(data.table, tidyverse, magrittr, leaflet, htmltools,
htmlwidgets)
#import data
read.csv("results_of_distance_estimation/wts_rlp_distances.csv")
#import data
read.csv("result_of_distance_estimation/wts_rlp_distances.csv")
#import data
wts_rlp_distances <- read.csv("result_of_distance_estimation/wts_rlp_distances.csv")
#remove WT's that have distance greater than 1000 m equal to zero
wts_rlp_filtered <- filter(wts_rlp_distances, nearest < 1000 & nearest != 0)
#omit NA values
wts_rlp_filtered <- na.omit(wts_rlp_filtered)
#remove WT's that have distance greater than 1000 m equal to zero
wts_rlp_filtered <- filter(wts_rlp_distances, nearest < 1000 & nearest != 0)
View(wts_rlp_filtered)
#omit NA values
sum(wts_rlp_filtered$menge_mwh)
#omit NA values
sum(wts_rlp_filtered$menge_mwh)
#omit NA values
sum(is.na(wts_rlp_filtered$menge_mwh))
wts_rlp_filtered <- na.omit(wts_rlp_filtered)
wts_rlp_filtered <- filter(wts_rlp_filtered, menge_mwh > 20)
wts_rlp_filtered <- filter(wts_rlp_filtered, nearest > 30)
#filter out with electricity yield per m2 above 100 kwh/m2
wts_rlp_filtered <- filter(wts_rlp_filtered, kwh_m2 < 100)
#change date formate
attach(wts_rlp_filtered)
wts_rlp_filtered$inbetriebnahme <- as.Date(
wts_rlp_filtered$inbetriebnahme, "%Y-%m-%d")
#create linear model
lm_e_yield_per_area <- lm(
wts_rlp_filtered$kwh_m2 ~ wts_rlp_filtered$inbetriebnahme)
summary(lm_e_yield_per_area)
#calculate average distance in relation to rotor diameter
mean(wts_rlp_filtered$d)
#calculate mean distance again and area consumption with average
mean(wts_rlp_filtered$nearest)
#calculate total mean electricity yield per m2
mean(wts_rlp_filtered$kwh_m2)
