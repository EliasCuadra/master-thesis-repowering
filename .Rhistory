annotate(geom="text",x=as.Date("1997-01-01"),
y=6500,label="mean of ~ 7,400 MWh/a in 2021 with linear trends", size = 2.5) +
geom_hline(yintercept = 10000, linetype = 'dashed', size = 0.25) +
annotate(geom="text",x=as.Date("2000-01-01"),
y=11000,label="mean of ~ 10,000 MWh/a in 2030 with linear trends", size = 2.5) +
geom_hline(yintercept = 15000, linetype = 'dashed', size = 0.25) +
annotate(geom="text",x=as.Date("2003-01-01"),
y=14200, label="> 15,000 MWh/a in 2030 with polynomial models", size = 2.5) +
annotate(geom="text",x=as.Date("2026-01-01"),
y=2000,label= "All adj. R² (3rd poly) ~ 72 %", size = 2.5) +
annotate(geom="text",x=as.Date("2026-01-01"),
y=3500,label= "All R² (linear) ~ 68 - 70 %", size = 2.5) +
annotate(geom="text",x=as.Date("2026-01-01"),
y=400,label="p-values all << 0.001", size = 2.5) +
scale_colour_manual(name = "Year", values=c("#03a1fc", "#fc5a03", "#94fc03"))
############
#print plot#
############
pelectricity_yield_2019_poly +  theme(legend.position = c(0.25,0.9))
####################
#save plot as image#
####################
ggsave("results_of_analysis/electricity_yield_2017-2019_rlp_over_comissioning_date2.png",
plot = last_plot(),
dpi = 900,
width = 7,
height = 4)
2300/8760
2300*3.5
Sys.setenv(LANG = "en")
pacman::p_load(rio, data.table, tidyverse, tidyr, purrr, magrittr, compare,
ggplot2, DiagrammeR)
Sys.setenv(LANG = "en")
#packages
pacman::p_load(rio, data.table, tidyverse, tidyr, purrr, magrittr)
#import data
MaStR <- read.csv("WTs_RLP.csv", sep = ";")
#choose variables
MaStR <- MaStR[,c(1, 5, 7, 16, 17, 18, 21, 22, 23, 24, 43)]
MaStR <- MaStR[,c(2:6,8,9,11)]
setwd("C:/Users/Dell/Desktop/MasterThesis/master-thesis-repowering/data/MaStR")
#import data
MaStR <- read.csv("WTs_RLP.csv", sep = ";")
#choose variables
MaStR <- MaStR[,c(1, 5, 7, 16, 17, 18, 21, 22, 23, 24, 43)]
MaStR <- MaStR[,c(2:6,8,9,11)]
View(MaStR)
View(MaStR)
#change collum names
names(MaStR)[1] <- "leistung"
names(MaStR)[2] <- "inbetrieb"
names(MaStR)[3] <- "gem"
names(MaStR)[4] <- "b_wgs84"
names(MaStR)[5] <- "l_wgs84"
names(MaStR)[6] <- "nabe"
names(MaStR)[7] <- "rotor"
names(MaStR)[8] <- "eeg_nr"
#check for Na's in coordinates
sum(is.na(MaStR$b_wgs84))
sum(is.na(MaStR$l_wgs84))
#import data
MaStR <- read.csv("WTs_RLP.csv", sep = ";", na.strings=c("","NA"))
#choose variables
MaStR <- MaStR[,c(1, 5, 7, 16, 17, 18, 21, 22, 23, 24, 43)]
MaStR <- MaStR[,c(2:6,8,9,11)]
#change collum names
names(MaStR)[1] <- "leistung"
names(MaStR)[2] <- "inbetrieb"
names(MaStR)[3] <- "gem"
names(MaStR)[4] <- "b_wgs84"
names(MaStR)[5] <- "l_wgs84"
names(MaStR)[6] <- "nabe"
names(MaStR)[7] <- "rotor"
names(MaStR)[8] <- "eeg_nr"
#check for Na's in coordinates
sum(is.na(MaStR$b_wgs84))
sum(is.na(MaStR$eeg_nr))
na.omit(MaStR)
MaStR_without_na <- na.omit(MaStR)
View(MaStR_without_na)
#check for Na's in coordinates
sum(is.na(MaStR$b_wgs84))
sum(is.na(MaStR$l_wgs84))
sum(is.na(MaStR$eeg_nr))
View(MaStR)
MaStR_without_na <- na.omit(MaStR$b_wgs84)
data_subset <- MaStR[ , c("l_wgs84", "egg_nr")]
data_subset <- MaStR[ , c(4,8)]
View(data_subset)
MaStR_without_na <- filter(MaStR, is.na(MaStR$b_wgs84) | is.na(MaStR$eeg_nr))
View(MaStR_without_na)
MaStR_without_na <- filter(MaStR, !is.na(MaStR$b_wgs84) | !is.na(MaStR$eeg_nr))
View(MaStR_without_na)
MaStR_without_na <- filter(MaStR, ! is.na(MaStR$b_wgs84) | ! is.na(MaStR$eeg_nr))
MaStR_without_na <- filter(MaStR, ! is.na(MaStR$eeg_nr))
sum(is.na(MaStR_without_na$b_wgs84))
MaStR_without_na <- filter(MaStR, ! is.na(MaStR$eeg_nr) & ! is.na(MaStR$b_wgs84))
sum(is.na(MaStR_without_na$b_wgs84))
rm(data_subset)
amprion2019 <- read.csv("Amprion/amprion_2019_processed.csv", na.strings=c("","NA"))
setwd("C:/Users/Dell/Desktop/MasterThesis/thesis_elias_cuadra_219202265/data/MaStR_amprion")
amprion2019 <- read.csv("../amprion/amprion_2019_processed.csv", na.strings=c("","NA"))
amprion2019 <- read.csv("../amprion/results_of_preparation/amprion_2019_processed_and_without_outliers.csv", na.strings=c("","NA"))
amprion2019 <- read.csv("amprion/results_of_preparation/amprion_2019_processed_and_without_outliers.csv", na.strings=c("","NA"))
amprion2019 <- read.csv("amprion_2019_processed_and_without_outliers.csv", na.strings=c("","NA"))
amprion2019 <- read.csv("amprion_2019_processed_and_without_outliers.csv", na.strings=c("","NA"))
View(amprion2019)
View(amprion2019)
View(MaStR_without_na)
View(amprion2019)
#import data
MaStR <- read.csv("WTs_RLP.csv", sep = ";", na.strings=c("","NA"))
#choose variables
MaStR <- MaStR[,c(1, 5, 7, 16, 17, 18, 21, 22, 23, 24, 43)]
MaStR <- MaStR[,c(2:6,8,9,11)]
#change collum names
names(MaStR)[1] <- "leistung_m"
names(MaStR)[2] <- "inbetrieb_m"
names(MaStR)[3] <- "gem_m"
names(MaStR)[4] <- "b_wgs84"
names(MaStR)[5] <- "l_wgs84"
names(MaStR)[6] <- "nabe_m"
names(MaStR)[7] <- "rotor_m"
names(MaStR)[8] <- "eeg_nr"
#check for Na's in coordinates
sum(is.na(MaStR$b_wgs84))
sum(is.na(MaStR$l_wgs84))
sum(is.na(MaStR$eeg_nr))
MaStR_without_na <- filter(MaStR, ! is.na(MaStR$eeg_nr) & ! is.na(MaStR$b_wgs84))
MaStR_without_na <- filter(MaStR, ! is.na(MaStR$eeg_nr) & ! is.na(MaStR$b_wgs84))
#import data
MaStR <- read.csv("WTs_RLP.csv", sep = ";", na.strings=c("","NA"))
#choose variables
MaStR <- MaStR[,c(1, 5, 7, 16, 17, 18, 21, 22, 23, 24, 43)]
MaStR <- MaStR[,c(2:6,8,9,11)]
#change column names
names(MaStR)[1] <- "leistung_m"
names(MaStR)[2] <- "inbetrieb_m"
names(MaStR)[3] <- "gem_m"
names(MaStR)[4] <- "b_wgs84"
names(MaStR)[5] <- "l_wgs84"
names(MaStR)[6] <- "nabe_m"
names(MaStR)[7] <- "rotor_m"
names(MaStR)[8] <- "eeg_nr"
MaStR_without_na <- filter(MaStR, ! is.na(MaStR$eeg_nr) & ! is.na(MaStR$b_wgs84))
pacman::p_load(rio, data.table, tidyverse, tidyr, purrr, magrittr, compare,
rgdal, raster, rgeos
)
MaStR_without_na <- filter(MaStR, ! is.na(MaStR$eeg_nr) & ! is.na(MaStR$b_wgs84))
View(MaStR_without_na)
#merge data sets
MaStR_amprion2019 <- merge(data.frame(MaStR_without_na), data.frame(amprion2019), by = "eeg_nr", all = TRUE)
#rename system key column
names(amprion2019)[7] <- "eeg_nr"
#merge data sets
MaStR_amprion2019 <- merge(data.frame(MaStR_without_na), data.frame(amprion2019), by = "eeg_nr", all = TRUE)
View(MaStR_amprion2019)
View(amprion2019)
amprion2019 <- amprion2019[,c(2:8)]
View(amprion2019)
#merge data sets
MaStR_amprion2019 <- merge(data.frame(MaStR_without_na), data.frame(amprion2019), by = "eeg_nr", all = TRUE)
#filter out NAs for EEG Nr. and remove duplicates
sum(is.na(MSB19_rename$eeg_nr))
#filter out NAs for EEG Nr. and remove duplicates
sum(is.na(MaStR_amprion2019$eeg_nr))
sum(dublicated(MaStR_amprion2019$eeg_nr))
sum(duplicated(MaStR_amprion2019$eeg_nr))
sum(is.na(MaStR_amprion2019$b_wgs84))
MaStR_amprion2019_without_na <- filter(MaStR_amprion2019, ! is.na(MaStR_amprion2019$b_wgs84))
sum(duplicated(MaStR_amprion2019_without_na$eeg_nr))
MaStR_amprion2019_without_dup <- distinct(MaStR_amprion2019_without_na)
MaStR_amprion2019_without_dup <- distinct(MaStR_amprion2019_without_na$eeg_nr)
MaStR_amprion2019_without_dup <- distinct(MaStR_amprion2019_without_na$eeg_nr, keep_all = TRUE)
sum(is.na(MaStR_amprion2019$b_wgs84))
#write csv
write.csv(MaStR_amprion2019_without_dup,"MaStR_amprion2019.csv")
20*10^12
2e+13/7400*10^6
2e+13/(7400*10^6)
2e+13/(8050*10^6)
setwd("C:/Users/Dell/Desktop/MasterThesis/thesis_elias_cuadra_219202265/data/Amprion")
Sys.setenv(LANG = "en")
pacman::p_load(rio, data.table, tidyverse, tidyr, purrr, magrittr, compare,
ggplot2, DiagrammeR)
################################
#Import data and format columns#
################################
amprion_2015 <- read.csv("EEG_StammBew_2015_Amprion-EAtlas.csv")
amprion_2016 <- read.csv("EEG_StammBew_2016_Amprion-EAtlas.csv")
amprion_2017 <- read.csv("EEG_StammBew_2017_Amprion-EAtlas.csv")
amprion_2018 <- read.csv("EEG_StammBew_2018_Amprion-EAtlas.csv")
amprion_2019 <- read.csv("EEG-StammBew_2019_Amprion-EAtlas.csv")
names(amprion_2019)[1] <- "gem"
names(amprion_2018)[1] <- "gem"
names(amprion_2017)[1] <- "gem"
####################
#Variable selection#
####################
selection_2015 <- amprion_2015[,c(1:3,8,10,17,27)]
selection_2016 <- amprion_2016[,c(1:3,8,10,17,27)]
selection_2017 <- amprion_2017[,c(1:3,8,10,17,27)]
selection_2018 <- amprion_2018[,c(1:3,8,10,17,27)]
selection_2019 <- amprion_2019[,c(1:3,7,9,16,26)]
###############################
#formatting commissioning date#
###############################
selection_2015$inbetriebnahme <- as.Date(selection_2015$inbetriebnahme, "%d/%m/%Y")
selection_2016$inbetriebnahme <- as.Date(selection_2016$inbetriebnahme, "%d/%m/%Y")
selection_2017$inbetriebnahme <- as.Date(selection_2017$inbetriebnahme, "%d/%m/%Y")
selection_2018$inbetriebnahme <- as.Date(selection_2018$inbetriebnahme, "%d/%m/%Y")
selection_2019$inbetriebnahme <- as.Date(selection_2019$inbetriebnahme, "%d/%m/%Y")
###############
#find outliers#
###############
outliers_2015 <- filter(selection_2015, leistung < 100 | leistung > 4500 | inbetriebnahme > "2015-02-15")
outliers_2016 <- filter(selection_2016, leistung < 100 | leistung > 4500 | inbetriebnahme > "2016-02-15")
outliers_2017 <- filter(selection_2017, leistung < 100 | leistung > 4500 | inbetriebnahme > "2017-02-15")
outliers_2018 <- filter(selection_2018, leistung < 100 | leistung > 4500 | inbetriebnahme > "2018-02-15")
outliers_2019 <- filter(selection_2019, leistung < 100 | leistung > 4500 | inbetriebnahme > "2019-02-15")
############################
#create df without outliers#
############################
selection_2015_without_outliers <- setdiff(selection_2015, outliers_2015)
selection_2016_without_outliers <- setdiff(selection_2016, outliers_2016)
selection_2017_without_outliers <- setdiff(selection_2017, outliers_2017)
selection_2018_without_outliers <- setdiff(selection_2018, outliers_2018)
selection_2019_without_outliers <- setdiff(selection_2019, outliers_2019)
#delete some
rm(selection_2015, selection_2016, selection_2017, selection_2018,selection_2019)
selection_2015_without_outliers <- selection_2015_without_outliers %>%
mutate(flh = menge_kwh/leistung) %>%
mutate(menge_mwh = round(menge_kwh/1000))
selection_2016_without_outliers <- selection_2016_without_outliers %>%
mutate(flh = menge_kwh/leistung) %>%
mutate(menge_mwh = round(menge_kwh/1000))
selection_2017_without_outliers <- selection_2017_without_outliers %>%
mutate(flh = menge_kwh/leistung) %>%
mutate(menge_mwh = round(menge_kwh/1000))
selection_2018_without_outliers <- selection_2018_without_outliers %>%
mutate(flh = menge_kwh/leistung) %>%
mutate(menge_mwh = round(menge_kwh/1000))
selection_2019_without_outliers <- selection_2019_without_outliers %>%
mutate(flh = menge_kwh/leistung) %>%
mutate(menge_mwh = round(menge_kwh/1000))
rm(outliers_2015, outliers_2016, outliers_2017, outliers_2018, outliers_2019, amprion_2015,
amprion_2016, amprion_2017, amprion_2018, amprion_2019)
commissioning_before2001 <- subset(selection_2019_without_outliers, inbetriebnahme < "2000-12-31")
sum(commissioning_before2001$menge_mwh)
commissioning_before2005 <- subset(selection_2019_without_outliers, inbetriebnahme < "2005-12-31")
commissioning_2001_2005 <- subset(commissioning_before2005, inbetriebnahme > "2000-12-31")
sum(commissioning_2001_2005$menge_mwh)
sum(commissioning_before2001$menge_mwh)
186392/1000
round(186.392*186)
7400/1000
round(7.4*186)
round((186/1376)*100)
round((1376/186)*100)
sum(commissioning_2001_2005$menge_mwh)
round(655267/1000)
round(328*7.4)
round((2427/655)*100)
Sys.setenv(LANG = "en")
pacman::p_load(rio, data.table, tidyverse, tidyr, purrr, magrittr, compare,
ggplot2, leaflet, sp, raster, rgdal, htmltools, htmlwidgets,
tmaptools, maptools, raster, sf, tmap, spatstat, rgeos)
MaStR_amprion <- read.csv("MaStR_amprion2019.csv")
attach(MaStR_amprion)
#change lat and long to numeric
MaStR_amprion$l_wgs84 <- gsub(",",".", l_wgs84)
MaStR_amprion$b_wgs84 <- gsub(",",".", b_wgs84)
MaStR_amprion$b_wgs84 <- as.numeric(MaStR_amprion$b_wgs84)
MaStR_amprion$l_wgs84 <- as.numeric(MaStR_amprion$l_wgs84)
#load boundaries of RLP
border_sf  <- st_read("Borders_RLP_shape/Landesgrenze_RLP.shp")
border_sp <- readOGR("Borders_RLP_shape/Landesgrenze_RLP.shp")
#create coordinate columns and check CRS
class(MaStR_amprion)
coordinates(MaStR_amprion) <- ~ l_wgs84 + b_wgs84
crs(MaStR_amprion)
#create crs
WGS84 <- CRS("+proj=longlat +datum=WGS84 +no_defs")
crs(MaStR_amprion) <- WGS84
crs(MaStR_amprion)
#clip those inside RLP
wts_rlp <- MaStR_amprion[border_sp,]
wts_rlp_df <- as.data.frame(wts_rlp)
#convert point layer to in sf format
wts_rlp_sf <- st_as_sf(wts_rlp)
crs(wts_sf)
class(wts_sf)
#transform point layer of wts to flat
wts_rlp_flat <- st_transform(wts_rlp_sf, crs = 6345)
plot(wts_flat)
#transform border polygon of RLP to flat
border_flat <- st_transform(border_sf, crs = 6345)
plot(wts_flat)
##############################
#PPA - Point Pattern Analysis#
##############################
#create ppp formate of WT's
wts_rlp_ppp  <- as.ppp(wts_rlp_flat)
plot(wts_rlp_ppp)
#create owin format
border_owin <- as.owin(border_flat)
#create window of points with borders of rlp and plot
Window(wts_rlp_ppp) <- border_owin
plot(wts_rlp_ppp, cols=rgb(0,0,0,.2), pch=20)
#calculate average nearest neighbor
mean(nndist(wts_rlp_ppp, k=1))
#~549m -----> seems reasonable
#calculate nearest neighbor
nearest <- nndist(wts_rlp_ppp, k=1)
wts_rlp_distances <- data.frame(wts_rlp_df, nearest)
wts_rlp_distances$nearest <- round(wts_rlp_distances$nearest)
#plot with leaflet
leaflet(data = wts_rlp_distances) %>%
addTiles() %>%
addPolygons(data = border_sp,
color = "#5DADE2",
weight = 2,
opacity = 0.6,
fillColor = "#5DADE200",
highlight = highlightOptions(weight = 7,
color = "#5DADE2",
fillColor = "#5DADE2",
fillOpacity = 0.3,
bringToFront = TRUE),
label = "Rheinland-Pfalz",
group = "Rheinland-Pfalz") %>%
addMarkers(lng = wts_rlp$l_wgs84,
lat = wts_rlp$b_wgs84,
clusterOptions = markerClusterOptions(disableClusteringAtZoom = 10),
popup = ~paste("<h3> Daten der Windkraftanlage</h3>",
"<b>Distance to next WT:</b>", nearest, "<br>"))
#clean environment
rm(border_sp, border_flat, border_owin, border_sf, wts_rlp_ppp, wts_rlp_flat,
wts_rlp_sf, nearest, MaStR_amprion, WGS84, wts_rlp_df, wts_rlp)
setwd("C:/Users/Dell/Desktop/MasterThesis/thesis_elias_cuadra_219202265/data/Area_consumption_of_wind_turbines")
MaStR_amprion <- read.csv("MaStR_amprion2019.csv")
attach(MaStR_amprion)
#change lat and long to numeric
MaStR_amprion$l_wgs84 <- gsub(",",".", l_wgs84)
MaStR_amprion$b_wgs84 <- gsub(",",".", b_wgs84)
MaStR_amprion$b_wgs84 <- as.numeric(MaStR_amprion$b_wgs84)
MaStR_amprion$l_wgs84 <- as.numeric(MaStR_amprion$l_wgs84)
#load boundaries of RLP
border_sf  <- st_read("Borders_RLP_shape/Landesgrenze_RLP.shp")
border_sp <- readOGR("Borders_RLP_shape/Landesgrenze_RLP.shp")
#create coordinate columns and check CRS
class(MaStR_amprion)
coordinates(MaStR_amprion) <- ~ l_wgs84 + b_wgs84
crs(MaStR_amprion)
#create crs
WGS84 <- CRS("+proj=longlat +datum=WGS84 +no_defs")
crs(MaStR_amprion) <- WGS84
crs(MaStR_amprion)
#clip those inside RLP
wts_rlp <- MaStR_amprion[border_sp,]
wts_rlp_df <- as.data.frame(wts_rlp)
#convert point layer to in sf format
wts_rlp_sf <- st_as_sf(wts_rlp)
crs(wts_sf)
class(wts_sf)
#transform point layer of wts to flat
wts_rlp_flat <- st_transform(wts_rlp_sf, crs = 6345)
plot(wts_flat)
#transform border polygon of RLP to flat
border_flat <- st_transform(border_sf, crs = 6345)
plot(wts_flat)
##############################
#PPA - Point Pattern Analysis#
##############################
#create ppp formate of WT's
wts_rlp_ppp  <- as.ppp(wts_rlp_flat)
plot(wts_rlp_ppp)
#create owin format
border_owin <- as.owin(border_flat)
#create window of points with borders of rlp and plot
Window(wts_rlp_ppp) <- border_owin
plot(wts_rlp_ppp, cols=rgb(0,0,0,.2), pch=20)
#calculate average nearest neighbor
mean(nndist(wts_rlp_ppp, k=1))
#~549m -----> seems reasonable
#calculate nearest neighbor
nearest <- nndist(wts_rlp_ppp, k=1)
wts_rlp_distances <- data.frame(wts_rlp_df, nearest)
wts_rlp_distances$nearest <- round(wts_rlp_distances$nearest)
#plot with leaflet
leaflet(data = wts_rlp_distances) %>%
addTiles() %>%
addPolygons(data = border_sp,
color = "#5DADE2",
weight = 2,
opacity = 0.6,
fillColor = "#5DADE200",
highlight = highlightOptions(weight = 7,
color = "#5DADE2",
fillColor = "#5DADE2",
fillOpacity = 0.3,
bringToFront = TRUE),
label = "Rheinland-Pfalz",
group = "Rheinland-Pfalz") %>%
addMarkers(lng = wts_rlp$l_wgs84,
lat = wts_rlp$b_wgs84,
clusterOptions = markerClusterOptions(disableClusteringAtZoom = 10),
popup = ~paste("<h3> Daten der Windkraftanlage</h3>",
"<b>Distance to next WT:</b>", nearest, "<br>"))
#clean environment
rm(border_sp, border_flat, border_owin, border_sf, wts_rlp_ppp, wts_rlp_flat,
wts_rlp_sf, nearest, MaStR_amprion, WGS84, wts_rlp_df, wts_rlp)
wts_rlp_filtered <- filter(wts_rlp_distances, nearest < 1000 & nearest != 0)
#omit NA values
wts_rlp_filtered <- na.omit(wts_rlp_filtered)
#create colum with mwh and area
wts_rlp_filtered <- wts_rlp_filtered %>%
mutate(menge_mwh = round(menge_kwh/1000)) %>%
mutate(area_m2 = round(nearest^2)) %>%
mutate(area_km2 = area_m2/1000000) %>%
mutate(kwh_m2 = menge_kwh/area_m2) %>%
mutate(d = round(nearest/rotor_m))
#filter those with electricity yield smaller than 10 Mwh and small distance
wts_rlp_filtered <- filter(wts_rlp_filtered, menge_mwh > 20)
wts_rlp_filtered <- filter(wts_rlp_filtered, nearest > 30)
#filter out with electricity yield per m2 above 100 kwh/m2
wts_rlp_filtered <- filter(wts_rlp_filtered, kwh_m2 < 100)
#change date formate
attach(wts_rlp_filtered)
wts_rlp_filtered$inbetriebnahme <- as.Date(wts_rlp_filtered$inbetriebnahme, "%Y-%m-%d")
#create linear model
lm_e_yield_per_area <- lm(wts_rlp_filtered$kwh_m2 ~ wts_rlp_filtered$inbetriebnahme)
summary(lm_e_yield_per_area)
p_e_yield_per_area <- ggplot() +
geom_point(data = wts_rlp_filtered, aes(x=inbetriebnahme, y=kwh_m2), size = 0.4, colour = "#0051fd") +
geom_smooth(data = wts_rlp_filtered, aes(x=inbetriebnahme, y=kwh_m2, colour = "2019"), method=lm, se=TRUE, fullrange = TRUE, size = 0.5)  +
theme_light() +
ylim(0,100) +
scale_x_date(limits = as.Date(c("1990-01-01","2030-12-31"))) +
xlab("Commissioning date") +
ylab("Electricity yield per m? and year [kWh/m?a]") +
theme( axis.text=element_text(size=11),
axis.title=element_text(size=12),
plot.title = element_text(size=14),
legend.position = c(0.85, 0.9),
legend.direction = "horizontal") +
geom_hline(yintercept = 27.4, linetype = 'dashed', size = 0.25) +
annotate(geom="text",x=as.Date("2025-01-01"),
y=25,label="Mean of 27.4 kWh/m?a after 2010", size = 2.5) +
annotate(geom="text",x=as.Date("2025-01-01"),
y=5,label= "R? = ~ 11 % \n p-value << 0.001") +
scale_colour_manual(name = "Joined data from MaStR and amprion", values="#0051fd")
#plot
p_e_yield_per_area +  theme(legend.position = c(0.7,0.9))
33.5(1000/8765)
33.5*(1000/8765)
1e+09/27.41782
#calculate total mean electricity yield per m2
mean(wts_rlp_filtered$kwh_m2)
(22*1e+09)/23.31935
943422522/1000000
(943.4225/19847)*100
4.753477/1.5
(22*1e+09)/27.41782
802397857/1000000
(802.3979/19847)*100
4.042918/1.5
(22*1e+09)/33.5
656716418/1000000
(656.7164/19847)*100
3.308895/1.5
3.1/1.3
3.1/(1.3*0.016)
3.1/(1.3*0.016*0.5)
sqrt(298.0769)
0.5*0.016*1.3
3.1/0.0104
2.2/0.0104
sqrt(211.5385)
0.016*140
0.016*140
0.016*0.5*6^3
6^3
0.016*0.5*216
0.016*0.5*216*1.3
3.1/(0.016*0.5*1.3)
298.0769^1/3
#27.41782 kWh/m2
#3.128103 W/m2
298.0769^ 1/3
#27.41782 kWh/m2
#3.128103 W/m2
298.0769 ^ 1/3
#27.41782 kWh/m2
#3.128103 W/m2
x <- 298.0769
x^1/3
x^1/2
x ^ 1/3
Sys.setenv(LANG = "en")
pacman::p_load(rio, data.table, tidyverse, tidyr, purrr, magrittr, compare,
ggplot2, leaflet, sp, raster, rgdal, htmltools, htmlwidgets,
tmaptools, maptools, raster, sf, tmap, spatstat, rgeos)
x ^ 1/3
x^1/3
x*1/3
x^2
x^(1/3)
3.8/(0.016*0.5*1.3)
y <- 365.3846
y^(1/3)
12/5
